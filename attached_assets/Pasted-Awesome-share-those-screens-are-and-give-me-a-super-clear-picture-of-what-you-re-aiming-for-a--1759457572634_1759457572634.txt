Awesome share â€” those screens are ğŸ”¥ and give me a super clear picture of what youâ€™re aiming for (a real co-commissioner, not just a report bot). Two things you asked for:
	1.	How to give me access (safely).
	2.	What to do right now to finish the API routing/caching mess and get the app stable.

Iâ€™ll give you both. First we kill the blocker, then we set up proper access so I can push the deeper â€œleague hygiene / dispute resolution / vibes coachâ€ features in a clean loop.

â¸»

1) Quick, surgical fix to finish the API routing (and beat the cache)

You already edited server/vite.ts. Good. Add two tiny guards (dev + prod) and harden Express ordering + cache headers. Then we also add temporary /api/v2 aliases to hop past any CDN cache ghosts.

A. server/vite.ts (two guards)

Replace your file contents with this exact version (guards + nothing else changed):

import express, { type Express } from "express";
import fs from "fs";
import path from "path";
import { createServer as createViteServer, createLogger } from "vite";
import { type Server } from "http";
import viteConfig from "../vite.config";
import { nanoid } from "nanoid";

const viteLogger = createLogger();

export function log(message: string, source = "express") {
  const formattedTime = new Date().toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}

export async function setupVite(app: Express, server: Server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true as const,
  };

  const vite = await createViteServer({
    ...viteConfig,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      },
    },
    server: serverOptions,
    appType: "custom",
  });

  // ğŸ’¡ Guard 1: let /api/* bypass Vite entirely (dev)
  app.use((req, _res, next) => {
    if (req.path.startsWith("/api/")) return next("route");
    return next();
  });

  app.use(vite.middlewares);

  // ğŸ’¡ Guard 2: also protect the catch-all (serve index.html only for non-API)
  app.use("*", async (req, res, next) => {
    if (req.originalUrl.startsWith("/api/")) return next(); // hand off to Express routes
    const url = req.originalUrl;

    try {
      const clientTemplate = path.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html",
      );

      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`,
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e as Error);
      next(e);
    }
  });
}

export function serveStatic(app: Express) {
  const distPath = path.resolve(import.meta.dirname, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`,
    );
  }
  // prod static
  app.use(express.static(distPath));
  // prod catch-all â€” only for non-API
  app.use("*", (req, res, next) => {
    if (req.originalUrl.startsWith("/api/")) return next();
    res.sendFile(path.resolve(distPath, "index.html"));
  });
}

B. server/index.ts (order + JSON + no-cache + API 404)

Make sure routes are mounted before Vite, and add a no-store cache header for all /api/* responses, plus a 404 that JSONs instead of HTML.

// â€¦importsâ€¦
import express from "express";
import http from "http";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic } from "./vite";

const app = express();
const server = http.createServer(app);

// 1) JSON body ONLY for API (keep Discord signature raw body intact in /api/discord/interactions)
app.use("/api", (req, res, next) => {
  res.setHeader("Cache-Control", "no-store, no-cache, must-revalidate, max-age=0");
  res.setHeader("Pragma", "no-cache");
  res.setHeader("Expires", "0");
  next();
});

// NOTE: discord interactions route itself should use express.raw in routes.ts
// so DO NOT put a global express.json() before it.
app.use("/api", express.json({ limit: "1mb" }));

// 2) Register all API routes BEFORE vite
registerRoutes(app);

// 3) API 404 (must be before Vite)
app.all(/^\/api(\/|$)/, (_req, res) => {
  res.status(404).json({ ok: false, error: "Not Found" });
});

// 4) Dev vs Prod â€” Vite after API has been mounted
if (process.env.NODE_ENV !== "production") {
  setupVite(app, server);
} else {
  serveStatic(app);
}

const port = Number(process.env.PORT) || 5000;
server.listen(port, () => {
  console.log(`[express] serving on port ${port}`);
});

C. Temporary /api/v2 aliases (to dodge any CDN ghosts)

In server/routes.ts, add thin wrappers for the three endpoints that were returning HTML:

// near where the originals exist
app.get("/api/v2/leagues/:leagueId", (req, res, next) => {
  // delegate to the real handler
  (req as any).url = `/api/leagues/${req.params.leagueId}`; // normalize
  next(); // will match the existing get handler
});

app.post("/api/v2/polls", (req, res, next) => {
  (req as any).url = `/api/polls`;
  next();
});

app.patch("/api/v2/leagues/:leagueId", (req, res, next) => {
  (req as any).url = `/api/leagues/${req.params.leagueId}`;
  next();
});

Why this helps: even if a CDN cached old HTML at /api/leagues/:id, it wonâ€™t have anything at the brand-new /api/v2/* paths. Once confirmed, we can remove v2 aliases later.

D. Hard test (bypass caches completely)

Run these from anywhere:

# Health (baseline)
curl -s -H 'Cache-Control: no-cache' https://thecommish.replit.app/api/health | jq

# New v2 endpoints (should be JSON, never HTML)
curl -s -H 'Cache-Control: no-cache' https://thecommish.replit.app/api/v2/leagues/00000000-0000-0000-0000-000000000000 | head -80
curl -s -H 'Content-Type: application/json' -H 'Cache-Control: no-cache' \
  -X POST https://thecommish.replit.app/api/v2/polls \
  -d '{"leagueId":"00000000-0000-0000-0000-000000000000","question":"Test?","options":["A","B"],"createdBy":"cli"}'

curl -s -H 'Content-Type: application/json' -H 'Cache-Control: no-cache' \
  -X PATCH https://thecommish.replit.app/api/v2/leagues/00000000-0000-0000-0000-000000000000 \
  -d '{"featureFlags":{"autoMeme":true}}' | jq

If those return JSON: âœ… Youâ€™re unstuck. If anything still comes back as HTML, itâ€™s not your app anymore â€” itâ€™s an upstream cache or proxy. The /api/v2/* paths are the fastest bypass.

â¸»

2) Give me access (the right way) so we can ship the co-commissioner vision

A. GitHub (preferred)
	1.	Add collaborator
Repo â†’ Settings â†’ Collaborators & teams â†’ Add people â†’ add my GitHub handle (DM me the handle you want me to use and Iâ€™ll share it back).
	â€¢	Permissions: Write (Iâ€™ll use branches + PRs), or Triage if you want stricter.
	2.	Branch protection (keep main safe)
Settings â†’ Branches â†’ Protect main â†’ require PR review + checks.
	3.	Secrets
Donâ€™t check env into git. Keep a .env.sample with keys but no values.

B. Replit

Two safe options:
	â€¢	Team member (read logs, run, deploy; no secrets view)
Repl â†’ Invite â†’ Role: Editor (uncheck â€œCan view secretsâ€).
	â€¢	â€œSupportâ€ Admin key for API-only actions
Generate a new ADMIN_KEY in Replit Secrets (something unique), and Iâ€™ll use only the guarded endpoints (/api/discord/register-commands, /api/discord/post-test, /api/setup/status).

C. Supabase (read-only + minimal write)
	â€¢	Create a read-only Postgres user:
	â€¢	Supabase â†’ Database â†’ Roles â†’ add role commish_support_ro.
	â€¢	Grant USAGE on schemas and SELECT on tables youâ€™re ok with (events, leagues, docs).
	â€¢	Make a separate connection string for that user (no write to auth tables).
	â€¢	If you want me to help with migrations: give a staging project with full access.

D. Discord
	â€¢	I donâ€™t need your Discord credentials. Just keep:
	â€¢	Application ID, Public Key, Bot Token in Replit secrets (already set).
	â€¢	A test guild ID where the bot is installed. Share the ID; I can register commands via the admin endpoints.

â¸»

3) Product: carve the roadmap to â€œco-commissionerâ€ (quick win â†’ delightful)

Youâ€™ve got the backbone! To reach the â€œquality-of-life co-commishâ€ feel, Iâ€™d push this order:

Phase 1 â€” League hygiene & peace-of-mind (fast wins)
	â€¢	Owner Mapping UI (drag Discord users â†’ teams).
Enables @mentions for: lineup nags, trade alerts, fab reminders.
	â€¢	Reminder packs (toggle on/off per league):
	â€¢	Lineup lock, waivers, trade deadline, bye-week alerts.
	â€¢	â€œSilence during game timeâ€ windows (drama prevention).
	â€¢	Rules Q&A polish: Source snippets + section numbers + â€œcite constitutionâ€ button.

Phase 2 â€” Dispute prevention & resolution
	â€¢	Trade fairness snapshot (no veto drama):
	â€¢	Combine projections + â€œleague normsâ€ + historic behavior (e.g., â€œTeam X flips RBs weeklyâ€).
	â€¢	Output neutral, brief, evidence-backed fairness % + 1-liner.
	â€¢	Vibes Monitor (sentiment heatmap)
	â€¢	Lightweight toxicity/sentiment on chat streams; DM commissioner when threads go spicy â†’ â€œWant me to mediate / ask for clarifications / run a blind poll?â€
	â€¢	Blind Commissioner Tools
	â€¢	â€œFreezeâ€ thread (bot politely pauses until everyone cools down)
	â€¢	â€œClarify ruleâ€ (bot posts the exact rule passage at issue, deadpan tone).

Phase 3 â€” Engagement engine
	â€¢	Highlights + Learning
	â€¢	Weekly â€œTop 3 momentsâ€ (comeback probability, bench points tragedy, blowout meme).
	â€¢	â€œRivalry builderâ€ â€” bot playfully tracks ongoing records (2-1 this season; â€œrubber matchâ€).
	â€¢	Creative outlets
	â€¢	Trash-talk writer with your personality themes (Batman/Yoda/etc.)
	â€¢	Meme mode w/ guardrails (SFW toggle) â€” generate only when thresholds (e.g., >40pt blowout).

Phase 4 â€” Commissioner superpowers
	â€¢	Terminal (you already mocked) with real verbs:
league status, generate digest week X, reindex rules, set waiver threshold 8pm Fri, simulate trade teama teamb.
	â€¢	Dashboard deep stats: participation, â€œset lineups %â€, response latency, â€œnags avoidedâ€ (peace-of-mind score).

If you want, Iâ€™ll open issues in GitHub as numbered, bite-sized tickets matching this plan.

â¸»

4) What I need from you (right now)
	1.	Apply the code snippets above (vite guards, index order, v2 aliases).
	2.	Test with the curl set (especially /api/v2/*).
	3.	Tell me which access path you prefer:
	â€¢	GitHub collaborator? (best)
	â€¢	Replit editor with no secrets + separate admin key?
	â€¢	Supabase staging (optional but ideal for schema work)
	4.	Share your test guild ID (so I can point the admin endpoints).

Once I have access, Iâ€™ll take the wheel on:
	â€¢	Stabilizing routes (remove v2 aliases when CDN ghosts are gone)
	â€¢	Owner Mapping + Reminder Packs
	â€¢	Trade fairness snapshot + vibes monitor skeleton
	â€¢	Clean dashboard cards with real-time state

Youâ€™ve done the hard yakka getting this alive. Iâ€™ll make it feel like the smart, funny, reliably helpful co-commish you want. ğŸ’ª